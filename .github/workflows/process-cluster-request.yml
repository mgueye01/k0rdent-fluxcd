name: Process Cluster Request

on:
  # Triggered when a PR with the cluster-request label is approved
  pull_request_review:
    types: [submitted]

jobs:
  process-cluster-request:
    # This workflow prepares the cluster configuration files
    # The actual cluster deployment happens after the PR is merged
    # See deploy-cluster-on-merge.yml for the deployment workflow
    if: |
      github.event.review.state == 'approved' &&
      contains(github.event.pull_request.labels.*.name, 'cluster-request')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.CLUSTER_REQUEST_PAT }}
          
      - name: Set up Git
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
      
      - name: Install gomplate
        run: |
          echo "Installing gomplate for templating..."
          curl -o /usr/local/bin/gomplate -sSL https://github.com/hairyhenderson/gomplate/releases/download/v3.11.5/gomplate_linux-amd64
          chmod +x /usr/local/bin/gomplate
        
      - name: Fetch PR details
        id: pr_details
        run: |
          # Store PR number for later use
          echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          
          # Fetch PR details using GitHub CLI and save to file
          gh pr view ${{ github.event.pull_request.number }} --json body -q .body > pr_body.txt
          
          echo "PR body saved to pr_body.txt"
        env:
          GH_TOKEN: ${{ secrets.CLUSTER_REQUEST_PAT }}
          
      - name: Extract cluster information from PR
        id: extract_cluster_info
        run: |
          # Create a temporary json file for gomplate to use
          echo "{}" > cluster_vars.json
          
          # Extract cluster name and add to JSON
          CLUSTER_NAME=$(grep -A 1 "**Cluster Name**:" pr_body.txt | tail -n 1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          jq --arg val "$CLUSTER_NAME" '. + {cluster_name: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Extract environment and add to JSON
          ENVIRONMENT=$(grep -A 1 "**Environment**:" pr_body.txt | tail -n 1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          jq --arg val "$ENVIRONMENT" '. + {environment: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Extract provider and add to JSON
          PROVIDER_LINE=$(grep -A 10 "**Provider**:" pr_body.txt | grep -m 1 "^- ")
          PROVIDER=$(echo "$PROVIDER_LINE" | sed 's/^- //;s/^[[:space:]]*//;s/[[:space:]]*$//')
          jq --arg val "$PROVIDER" '. + {provider: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Extract management cluster and add to JSON
          MANAGEMENT_CLUSTER=$(grep -A 1 "**Management Cluster**:" pr_body.txt | tail -n 1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          jq --arg val "$MANAGEMENT_CLUSTER" '. + {management_cluster: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Extract region and add to JSON
          REGION=$(grep -A 1 "**Region/Location**:" pr_body.txt | tail -n 1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          jq --arg val "$REGION" '. + {region: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Extract resource sizes
          RESOURCE_SIZE=$(grep -A 5 "**Resource Size**:" pr_body.txt | grep -v "<!--")
          
          # Extract control plane instance type based on provider
          if [[ "$PROVIDER" == *"aws"* ]]; then
            CP_LINE=$(echo "$RESOURCE_SIZE" | grep -i "control plane")
            CONTROL_PLANE_INSTANCE_TYPE=$(echo "$CP_LINE" | grep -o -E '(t|m|c)[0-9]\.[a-z0-9]+' || echo "t3.medium")
            
            WORKER_LINE=$(echo "$RESOURCE_SIZE" | grep -i "worker")
            WORKER_INSTANCE_TYPE=$(echo "$WORKER_LINE" | grep -o -E '(t|m|c)[0-9]\.[a-z0-9]+' || echo "t3.large")
          elif [[ "$PROVIDER" == *"azure"* ]]; then
            CP_LINE=$(echo "$RESOURCE_SIZE" | grep -i "control plane")
            CONTROL_PLANE_INSTANCE_TYPE=$(echo "$CP_LINE" | grep -o -E 'Standard_[A-Za-z][0-9][A-Za-z0-9_]+' || echo "Standard_D2s_v3")
            
            WORKER_LINE=$(echo "$RESOURCE_SIZE" | grep -i "worker")
            WORKER_INSTANCE_TYPE=$(echo "$WORKER_LINE" | grep -o -E 'Standard_[A-Za-z][0-9][A-Za-z0-9_]+' || echo "Standard_D4s_v3")
          else
            CONTROL_PLANE_INSTANCE_TYPE="medium"
            WORKER_INSTANCE_TYPE="large"
          fi
          
          # Add instance types to JSON
          jq --arg val "$CONTROL_PLANE_INSTANCE_TYPE" '. + {control_plane_instance_type: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          jq --arg val "$WORKER_INSTANCE_TYPE" '. + {worker_instance_type: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Extract node count and add to JSON
          NODE_COUNT=$(grep -A 1 "**Node Count**:" pr_body.txt | tail -n 1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' || echo "2")
          jq --arg val "$NODE_COUNT" '. + {node_count: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Calculate min and max node counts
          MIN_NODE_COUNT=$(echo "$NODE_COUNT" | awk '{print ($1 > 1) ? $1 - 1 : $1}')
          MAX_NODE_COUNT=$(echo "$NODE_COUNT" | awk '{print $1 * 2}')
          jq --arg val "$MIN_NODE_COUNT" '. + {min_node_count: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          jq --arg val "$MAX_NODE_COUNT" '. + {max_node_count: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Extract team and add to JSON
          TEAM=$(grep -A 1 "**Team**:" pr_body.txt | tail -n 1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          jq --arg val "$TEAM" '. + {team: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Extract purpose and add to JSON
          PURPOSE=$(grep -A 1 "**Purpose**:" pr_body.txt | tail -n 1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          jq --arg val "$PURPOSE" '. + {purpose: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Extract cost center and add to JSON
          COST_CENTER=$(grep -A 1 "**Cost Center**:" pr_body.txt | tail -n 1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' || echo "default")
          jq --arg val "$COST_CENTER" '. + {cost_center: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Add timestamp to JSON
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          jq --arg val "$TIMESTAMP" '. + {created_at: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          jq --arg val "${{ github.event.pull_request.number }}" '. + {pr_number: $val}' cluster_vars.json > tmp.json && mv tmp.json cluster_vars.json
          
          # Validate required parameters
          if [ -z "$CLUSTER_NAME" ] || [ -z "$PROVIDER" ] || [ -z "$MANAGEMENT_CLUSTER" ]; then
            echo "Error: Missing required parameters in PR description"
            exit 1
          fi
          
          # Export variables to environment for use in other steps
          jq -r 'to_entries | .[] | "echo \"\(.key)=\(.value)\" >> $GITHUB_ENV"' cluster_vars.json > export_vars.sh
          chmod +x export_vars.sh
          ./export_vars.sh
          
          # Debug output
          echo "Extracted parameters:"
          cat cluster_vars.json
      
      - name: Generate Cluster Deployment file
        run: |
          TARGET_DIR="management-clusters/${{ env.management_cluster }}/k0rdent/cluster-deployments/${{ env.cluster_name }}"
          mkdir -p "$TARGET_DIR"
          
          # Copy the template file for the provider
          TEMPLATE_FILE=".github/templates/cluster-deployments/${{ env.provider }}/template.yaml"
          if [ ! -f "$TEMPLATE_FILE" ]; then
            echo "Error: Template for provider ${{ env.provider }} not found"
            exit 1
          fi
          
          # Use gomplate to generate the deployment file from the template
          gomplate -f "$TEMPLATE_FILE" -d cluster=cluster_vars.json -o "$TARGET_DIR/cluster-deployment.yaml"
          
          # Create kustomization.yaml
          cat > "$TARGET_DIR/kustomization.yaml" << EOF
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization
          resources:
          - cluster-deployment.yaml
          EOF
          
          # Update main kustomization.yaml for cluster-deployments
          MAIN_KUSTOMIZATION="management-clusters/${{ env.management_cluster }}/k0rdent/cluster-deployments/kustomization.yaml"
          
          # Create the main kustomization.yaml if it doesn't exist
          if [ ! -f "$MAIN_KUSTOMIZATION" ]; then
            mkdir -p $(dirname "$MAIN_KUSTOMIZATION")
            cat > "$MAIN_KUSTOMIZATION" << EOF
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization
          resources: []
          EOF
          fi
          
          if grep -q "${{ env.cluster_name }}" "$MAIN_KUSTOMIZATION"; then
            echo "Cluster already exists in kustomization.yaml, skipping update"
          else
            # Check if resources: [] is in the file and replace it
            if grep -q "resources: \[\]" "$MAIN_KUSTOMIZATION"; then
              sed -i "s|resources: \[\]|resources:\n- ${{ env.cluster_name }}|g" "$MAIN_KUSTOMIZATION"
            else
              # Append to existing resources list
              sed -i "/resources:/a \ - ${{ env.cluster_name }}" "$MAIN_KUSTOMIZATION"
            fi
          fi
          
          # Generate metadata file using gomplate
          cat > "$TARGET_DIR/k0rdent-metadata.yaml" << EOF
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: ${{ env.cluster_name }}-metadata
            namespace: k0rdent-system
          data:
            cluster_name: "${{ env.cluster_name }}"
            provider: "${{ env.provider }}"
            environment: "${{ env.environment }}"
            region: "${{ env.region }}"
            management_cluster: "${{ env.management_cluster }}"
            team: "${{ env.team }}"
            purpose: "${{ env.purpose }}"
            cost_center: "${{ env.cost_center }}"
            created_at: "${{ env.created_at }}"
            created_by: "github-actions"
            pr_number: "${{ env.pr_number }}"
          EOF
          
          # Update the cluster kustomization to include the metadata
          sed -i "/- cluster-deployment.yaml/a \ - k0rdent-metadata.yaml" "$TARGET_DIR/kustomization.yaml"
          
      - name: Commit changes
        run: |
          git add management-clusters/${{ env.management_cluster }}/k0rdent/cluster-deployments/${{ env.cluster_name }}
          git add management-clusters/${{ env.management_cluster }}/k0rdent/cluster-deployments/kustomization.yaml
          git commit -m "Add ClusterDeployment for ${{ env.cluster_name }} on ${{ env.provider }}"
          git remote set-url origin https://x-access-token:${{ secrets.CLUSTER_REQUEST_PAT }}@github.com/${{ github.repository }}.git
          git push origin HEAD:${{ github.event.pull_request.head.ref }}
          
      - name: Add merge instructions comment
        run: |
          # Add a comment to the PR with instructions for merging
          gh pr comment ${{ github.event.pull_request.number }} --body "
          ## :white_check_mark: Cluster Configuration Ready
          
          The cluster configuration for **${{ env.cluster_name }}** has been prepared and added to this PR.
          
          ### Next Steps:
          1. Review the generated configuration in \`management-clusters/${{ env.management_cluster }}/k0rdent/cluster-deployments/${{ env.cluster_name }}/\`
          2. Make any necessary adjustments to the configuration
          3. **Merge this PR** to trigger the cluster deployment
          
          Once merged, the cluster configuration will be picked up by ArgoCD and k0rdent will create the cluster.
          "
        env:
          GH_TOKEN: ${{ secrets.CLUSTER_REQUEST_PAT }} 